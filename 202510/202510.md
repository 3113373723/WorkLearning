# 学习笔记
## 统计仓库代码量
网上的方法统计的不太准确
```
git ls-files | xargs wc -l | awk '{print sum+=$1}; END {print sum}'
```
推荐使用
```
git log --pretty=format: --numstat|awk '{add += $1; subs += $2; loc += $1-$2} END {printf "added lines:%s, removed lines:%s, total lines: %s\n", add, subs, loc}'
```
Visual STUDIO也有统计代码量的方法，但不知道为什么在我电脑不适用
## ZeroMQ
ZeroMQ (也写作 ØMQ, 0MQ 或 ZMQ) 是一个高性能的异步消息传递库，旨在用于分布式或并发应用程序。它提供了一个消息队列，无需一个专门的消息代理服务器。

为什么选择 ZeroMQ？
- 轻量级: 没有中心化的代理服务器，减少了系统的复杂性
- 高性能: 专注于低延迟和高吞吐量
- 灵活多样: 支持多种消息传递模式
- 跨平台: 可在多种操作系统上运行
- 多语言支持: 有多种编程语言的绑定
- 易于使用: 简单的 Socket 风格 API

基本通信方式
- ​请求-回复（REQ-REP）​​：用于同步的请求-回复模式，类似HTTP。
- ​发布-订阅（PUB-SUB）​​：用于一对多的消息分发，发布者发送消息，订阅者接收感兴趣的消息。
​- ​推-拉（PUSH-PULL）​​：用于管道模式，消息从推端流向拉端，适合负载均衡。
- ​配对（PAIR）​​：用于一对一的通信，两个套接字直接连接。
- ​路由-委托（ROUTER-DEALER）​​：用于高级的请求-回复模式，可以构建复杂的代理结构。
## 共享内存
```
QSharedMemory::QSharedMemory(const QString &key, QObject *parent = nullptr)
使用给定的父对象构造一个共享内存对象，并将其键设置为key。因为它的key被设置了，它的create ()和attach ()函数就可以调用了。    
    
QSharedMemory::QSharedMemory(QObject *parent = nullptr)
此函数重载 QSharedMemory()。
使用给定的parent构造一个共享内存对象。共享内存对象的键不是由构造函数设置的，因此共享内存对象没有附加底层共享内存段。
在调用`create()`或者attach()之前必须使用setKey()或者setNativeKey()设置Key.

    
[virtual] QSharedMemory::~QSharedMemory()
析构函数清除Key，这会强制共享内存对象与其底层共享内存段分离。如果此共享内存对象是最后一个连接到共享内存段的对象，则detach () 操作会销毁共享内存段。
    
bool QSharedMemory::attach(QSharedMemory::AccessMode mode = ReadWrite)
尝试将进程关联到由传递给构造函数或调用setKey () 或setNativeKey ()的密钥标识的共享内存段。
访问方式默认为ReadWrite。
它也可以是ReadOnly。true如果附加操作成功则返回。如果返回false，则调用error ()来判断发生了哪个错误。
附加共享内存段后，可以通过调用data ()获得共享内存的指针。    
    
const void *QSharedMemory::constData() const
返回一个指向共享内存段内容的常量指针，如果有的话。否则返回空值。记得在对共享内存进行读写之前用lock ()锁住共享内存，完成后记得用unlock ()释放锁。
    
bool QSharedMemory::create(int size, QSharedMemory::AccessMode mode = ReadWrite)
使用传递给构造函数的键创建大小为size字节的共享内存段，使用setKey () 或使用setNativeKey ()设置key，
然后使用给定的访问模式关联到新的共享内存段并返回true。如果key标识的共享内存段已经存在，则不执行attach操作并false返回。当返回值为 时false，
调用error ()来判断发生了哪个错误。    
    
void *QSharedMemory::data()    
返回一个指向共享内存段内容的指针，如果有的话。否则返回空值。记得在对共享内存进行读写之前用lock ()锁住共享内存，完成后记得用unlock ()释放锁。
    
const void *QSharedMemory::data() const
此函数重载 data()。
    
    
bool QSharedMemory::detach()
从共享内存段中分离进程。如果这是最后一个附加到共享内存段的进程，那么共享内存段将被系统释放，即内容被销毁。
true如果它分离共享内存段，则该函数返回。如果它返回false，通常意味着该段没有被附加，或者它被另一个进程锁定。
    
QSharedMemory::SharedMemoryError QSharedMemory::error() const
返回一个值，该值指示是否发生了错误，如果发生了，则是哪个错误。
    
QString QSharedMemory::errorString() const
返回最后发生的错误的文本描述。如果error () 返回错误值，则调用此函数以获取描述错误的文本字符串。
    
    
bool QSharedMemory::isAttached() const
返回true此进程是否附加到共享内存段。
    
QString QSharedMemory::key() const    
返回用setKey ()分配给这个共享内存的键，如果没有分配键，或者段使用nativeKey () ，则返回空键。
密钥是 Qt 应用程序用来标识共享内存段的标识符。

您可以通过调用nativeKey ()找到操作系统使用的本机、特定于平台的key。    
    
bool QSharedMemory::lock()
这是一个信号量，它锁定共享内存段以供此进程访问并返回true。如果另一个进程锁定了该段，则该函数将阻塞，
直到锁定被释放。然后它获取锁并返回true。如果此函数返回false，则表示您忽略了来自create () 或attach ()
的 false 返回，您已使用setNativeKey ()设置key或QSystemSemaphore::acquire () 由于未知系统错误而失败。    
    
QString QSharedMemory::nativeKey() const
返回此共享内存对象的本机、特定于平台的key。本机key是操作系统用来标识共享内存段的标识符。
您可以使用本机key访问不是由 Qt 创建的共享内存段，或授予非 Qt 应用程序共享内存访问权限。    
    
void QSharedMemory::setKey(const QString &key)
为这个共享内存对象设置平台无关的键。如果key与当前 key 相同，则函数不执行任何操作就返回。
您可以调用key () 来检索平台无关的密钥。在内部，QSharedMemory将此密钥转换为特定于平台的密钥。
如果您改为调用nativeKey ()，您将获得特定于平台的转换后的密钥。
如果共享内存对象附加到底层共享内存段，它将在设置新密钥之前与其分离。这个函数不做attach ()。
    
    
void QSharedMemory::setNativeKey(const QString &key)
设置此共享内存对象的本机、特定于平台的键。如果key与当前本机 key 相同，则该函数不执行任何操作就返回。
如果您只想为段分配一个键，则应改为调用setKey ()。
您可以调用nativeKey () 来检索本机密钥。如果已分配本机键，则调用key () 将返回空字符串。
如果共享内存对象附加到底层共享内存段，它将在设置新密钥之前与其分离。这个函数不做attach ()。
如果您设置本机密钥，该应用程序将不可移植。
 
 
int QSharedMemory::size() const    
返回附加共享内存段的大小。如果没有附加共享内存段，则返回 0。
注意：段的大小可能大于传递给create ()的请求大小。
    
    
bool QSharedMemory::unlock()
如果该进程当前持有该锁，则释放共享内存段上的锁并返回true。如果该段没有被锁定，或者如果该锁定被另一个进程持有，
则什么都不会发生并且返回 false。    
```    
### 程序示例
```
#include <QCoreApplication>


#include <QSharedMemory>
#include <QDebug>


int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);


    //共享内存对象
    QSharedMemory shareMemory;

    //设置共享内存的键 没有设置key之前默认为空
    qDebug() << "Key: " << shareMemory.key();

    //设置共享内存的Key
    shareMemory.setKey("Qt");
    qDebug() << "Key: " << shareMemory.key();

    //默认共享内存是没有关联的
    qDebug() << "isAttached: " << shareMemory.isAttached();

    //对应Key的共享内存不存在，因此关联失败
    qDebug() << shareMemory.attach();
    qDebug() << shareMemory.errorString();

    //判断该进程是否与共享内存关联
    if (shareMemory.isAttached())
    {
        if (!shareMemory.detach())
        {
            qDebug() << shareMemory.errorString();
            return -1;
        }
    }


    //默认读写的方式创建共享内存 创建的同时自动关联到该共享内存
    if (!shareMemory.create(1024))
    {
        qDebug() << shareMemory.errorString();
        return -1;
    }

    qDebug() << "isAttached: " << shareMemory.isAttached();
    qDebug() << "size: " << shareMemory.size();


    //加锁
    qDebug() << "lock: " << shareMemory.lock();

    //获取共享内存的起始地址
    void *data = shareMemory.data();
    qDebug() << "Addr: " << data;

    //拷贝数据
    memcpy(data, "hello", strlen("hello"));

    //解锁
    qDebug() << "unlock: " << shareMemory.unlock();

    //解除与共享内存的关联
    qDebug() << "detach: " << shareMemory.detach();


    return 0;
}


```
输出结果
```
Key:  ""
Key:  "Qt"
isAttached:  false
false
"QSharedMemory::handle: doesn't exist"
isAttached:  true
size:  4096
lock:  true
Addr:  0x29d0000
unlock:  true
detach:  true
```

## 多线程
```
#include<thread>
std::thread thread_object(callable, args...);
```
- callable：可调用对象，可以是函数指针、函数对象、Lambda 表达式等。
- args...：传递给 callable 的参数列表。

### join()
join() 用于等待线程完成执行。如果不调用 join() 或 detach() 而直接销毁线程对象，会导致程序崩溃。

### detach()
detach() 将线程与主线程分离，线程在后台独立运行，主线程不再等待它。

# Qt中文乱码问题
## QString显示中文乱码的原因
QString内部采用unicode字符集，utf-16编码。构造函数QString::QString(const char *str)默认使用fromUtf8()，将str所指的执行字符集从utf-8转码成utf-16。

显示中文乱码的原因其实就是QString转码方式与执行字符集不一致。(比如，源字符集为本地字符集GBK编码，QString以utf-8的方式进行解码，会导致获得错误的二进制编码，再将错误二进制转为utf-16就会出现乱码。)
## 解决方案
1、如果IDE是Qt Creator，把它的环境设置为“UTF-8+BOM”编码。

2、如果IDE是Visual Studio，请下载插件，名称是ForceUTF8 (with BOM)，所有源文件和头文件都会保存为“UTF-8+BOM”编码。

3、如果编译器是MSVC，请在预编译头stdafx.h文件加入
```
#if defined(_MSC_VER) && (_MSC_VER >= 1600)
    pragma execution_character_set(“utf-8”)
#endif
```
4、源码文件main函数入口设置中文编码：
```
#include <QFont>
#include <QTextCodec>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    //设置中文字体  
    a.setFont(QFont("Microsoft Yahei", 9));

    //设置中文编码
    #if (QT_VERSION <= QT_VERSION_CHECK(5,0,0))
    #if _MSC_VER
        QTextCodec *codec = QTextCodec::codecForName("gbk");
    #else
        QTextCodec *codec = QTextCodec::codecForName("utf-8");
    #endif
        QTextCodec::setCodecForLocale(codec);
        QTextCodec::setCodecForCStrings(codec);
        QTextCodec::setCodecForTr(codec);
    #else
        QTextCodec *codec = QTextCodec::codecForName("utf-8");
        QTextCodec::setCodecForLocale(codec);
    #endif

    MainView w;

    w.show();

    return a.exec();
}
```
参考原文链接：https://blog.csdn.net/m0_46577050/article/details/133804929
## 基础概念
UTF-8 BOM 和 UTF-8。

BOM在文件头位置占三个字节，用来标识UTF-8编码，软件通过BOM来识别这个文件是否是UTF-8编码。
源码字符集。源码文件使用某种编码格式保存。
执行字符集。可执行程序内保存的编码(程序执行时内存中字符串编码)。
QString中统一采用utf-16（Unicode）存储字符串。

QString::fromxxx()函数。

代表将字符串以对应格式去解析成Unicode,fromLocal8Bit()代表使用本地字符集（系统设置）转换成Unicode；fromUtf8代表从utf-8转换成Unicode。Qt程序运行的时候字符串编码在QString中实际都是以unicode编码存储的,通过使用QString::fromxxx()转换成转换成unicode存到QString中。
